<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vimidio</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        canvas {
            display: block;
        }
        #ui-panel {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.8);
            padding: 10px;
            border-radius: 5px;
        }
        #keyboard {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100px;
            display: flex;
        }
        .key {
            flex: 1;
            border: 1px solid #000;
            background: #fff;
            height: 100%;
        }
        .key.black {
            background: #000;
            height: 70%;
            width: 50%;
            margin-left: -25%;
            z-index: 1;
        }
        .key.active {
            background: #ff0000;
        }
        label {
            display: block;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <canvas id="visualizer"></canvas>
    <div id="ui-panel">
        <button id="record-button">Record</button>
        <button id="save-button" style="display:none;">Save Video</button>
        <label>Color: <input type="color" id="color-picker" value="#0096FF"></label>
        <label>Speed: <input type="range" id="speed-slider" min="1" max="20" value="5"></label>
        <label>Size: <input type="range" id="size-slider" min="5" max="30" value="10"></label>
    </div>
    <div id="keyboard"></div>
    <script src="https://cdn.jsdelivr.net/npm/@tonejs/midi"></script>
    <script>
        const canvas = document.getElementById('visualizer');
        const ctx = canvas.getContext('2d');
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        const particles = [];
        const splashDecay = 0.01; // How much particles fade out over time
        const maxParticles = 50; // Limit to the number of particles for each note
        const keys = []; // Track active keys for visual keyboard

        let midiAccess = null;
        const activeNotes = new Set(); // Track active notes

        // UI Elements
        const recordButton = document.getElementById('record-button');
        const saveButton = document.getElementById('save-button');
        const colorPicker = document.getElementById('color-picker');
        const speedSlider = document.getElementById('speed-slider');
        const sizeSlider = document.getElementById('size-slider');
        let recording = false;
        let recordedNotes = [];

        // MediaRecorder setup
        let mediaRecorder;
        let recordedChunks = [];

        function setup() {
            navigator.requestMIDIAccess()
                .then(access => {
                    midiAccess = access;
                    for (const input of midiAccess.inputs.values()) {
                        input.onmidimessage = onMIDIMessage;
                    }
                })
                .catch(err => {
                    console.error('Failed to get MIDI access:', err);
                    alert('MIDI not supported or failed to access MIDI devices.');
                });
            
            createKeyboard();
            recordButton.addEventListener('click', toggleRecording);
            saveButton.addEventListener('click', saveVideo);
            
            setupMediaRecorder();
        }

        function onMIDIMessage(message) {
            const [status, note, velocity] = message.data;
            const isNoteOn = status === 0x90 && velocity > 0;
            const isNoteOff = status === 0x80 || (status === 0x90 && velocity === 0);

            if (isNoteOn) {
                activeNotes.add(note);
                if (recording) recordedNotes.push({note, time: performance.now()});
                spawnWaterSplash(note);
                highlightKey(note, true);
            }
            if (isNoteOff) {
                activeNotes.delete(note);
                highlightKey(note, false);
            }
        }

        function spawnWaterSplash(note) {
            const noteX = mapNoteToX(note);
            for (let i = 0; i < 1; i++) { // Adjusted number of particles
                particles.push({
                    x: noteX + (Math.random() * 20 - 10), // Add random x offset
                    y: canvas.height,
                    size: Math.random() * sizeSlider.value + 5,
                    velocityY: Math.random() * -speedSlider.value - 2, // Speed adjusted by slider
                    alpha: 1,
                    color: colorPicker.value // Color from picker
                });
            }
        }

        function mapNoteToX(note) {
            const noteIndex = note - 21; // A0 is MIDI note 21
            const noteWidth = canvas.width / 88; // Assuming 88 keys
            return (noteIndex) * noteWidth;
        }

        function updateParticles() {
            for (const particle of particles) {
                particle.y += particle.velocityY;
                particle.alpha -= splashDecay;
                if (particle.alpha <= 0) {
                    particles.splice(particles.indexOf(particle), 1);
                }
            }
        }

        function drawParticles() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            for (const particle of particles) {
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                ctx.fillStyle = particle.color;
                ctx.globalAlpha = particle.alpha;
                ctx.fill();
            }
            ctx.globalAlpha = 1; // Reset alpha for other drawing operations
        }

        function animate() {
            if (activeNotes.size > 0) {
                for (const note of activeNotes) {
                    spawnWaterSplash(note);
                }
            }
            updateParticles();
            drawParticles();
            requestAnimationFrame(animate);
        }

        function createKeyboard() {
            const keyboardContainer = document.getElementById('keyboard');
            for (let i = 0; i < 88; i++) {
                const key = document.createElement('div');
                key.className = 'key' + ((i % 12 === 1 || i % 12 === 3 || i % 12 === 6 || i % 12 === 8 || i % 12 === 10) ? ' black' : '');
                keyboardContainer.appendChild(key);
                keys.push(key);
            }
        }

        function highlightKey(note, active) {
            const noteIndex = note - 21;
            if (keys[noteIndex]) {
                keys[noteIndex].classList.toggle('active', active);
            }
        }

        function toggleRecording() {
            recording = !recording;
            recordButton.textContent = recording ? 'Stop Recording' : 'Record';
            if (recording) {
                recordedChunks = [];
                mediaRecorder.start();
                saveButton.style.display = 'none';
            } else {
                mediaRecorder.stop();
                saveButton.style.display = 'block';
            }
        }

        function saveVideo() {
            const blob = new Blob(recordedChunks, { type: 'video/webm' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.style.display = 'none';
            a.href = url;
            a.download = 'VimidioRecording.webm';
            document.body.appendChild(a);
            a.click();
            URL.revokeObjectURL(url);
        }

        function setupMediaRecorder() {
            const stream = canvas.captureStream();
            mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm' });

            mediaRecorder.ondataavailable = (e) => {
                if (e.data.size > 0) {
                    recordedChunks.push(e.data);
                }
            };

            mediaRecorder.onstop = () => {
                saveButton.style.display = 'block';
            };
        }

        setup();
        animate();
    </script>
</body>
</html>